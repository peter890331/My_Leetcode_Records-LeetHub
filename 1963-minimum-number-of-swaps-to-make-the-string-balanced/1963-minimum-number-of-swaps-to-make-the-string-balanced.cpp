class Solution {
public:
    int minSwaps(string s) {
        int size = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            char ch = s[i];
            if (ch == '[')
                size++;
            else if (size > 0) 
                size--;
        }
        return (size + 1) / 2;
    }
};

// violet_6's solution.

// 具体解释代码：
// int size = 0; 定义了一个变量 size 来追踪未匹配的 '[' 数量。
// int n = s.size(); 获取字符串 s 的长度。
// for (int i = 0; i < n; i++) { 遍历字符串中的每一个字符：
// 如果当前字符是 '['，就将 size 增加 1，表示遇到了一个未匹配的左括号。
// 如果当前字符是 ']'，并且之前有未匹配的左括号（即 size > 0），就将 size 减少 1，表示这对方括号匹配成功。
// return (size + 1) / 2;：最后返回的结果是 (size + 1) / 2，表示未匹配的 '[' 和 ']' 对数的一半（向上取整），即需要通过交换的最小次数。

// 举例说明：
// 假设输入是字符串 s = '[]]][['：
// 第一次遍历时，遇到第一个 '['，size 增加到 1。
// 遇到三个连续的 ']'，但只有一个 '['，所以只匹配一个，size 降为 0。
// 后面的两个 '[' 都是未匹配的，因此 size 最后等于 2。
// 最终 size 为 2，则最小交换次数为 (2 + 1) / 2 = 1。

// 为什么是 (size + 1) / 2：
// 当 size 是偶数时：我们需要交换一半的未匹配括号，交换次数为 size / 2。例如，size = 2，只需要 1 次交换就能将两个未匹配的左括号与两个右括号配对。
// 当 size 是奇数时：最小的交换次数需要处理 size 的一半，向上取整（即 (size + 1) / 2）。例如，如果 size = 3，虽然有 3 个未匹配的左括号，但我们可以通过 2 次交换处理这 3 个括号和它们相应的 ']'。