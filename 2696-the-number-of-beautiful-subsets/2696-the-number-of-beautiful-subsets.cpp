class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        count = 0;
        explore(nums, k, 0);
        return count - 1; // Subtract 1 to exclude the empty subset
    }

private:
    int count;
    unordered_map<int, int> visited;

    void explore(vector<int>& nums, int k, int index) {
        if (index == nums.size()) {
            count++;
            return;
        }

        int num = nums[index];

        if (visited.find(num - k) == visited.end() && visited.find(num + k) == visited.end()) {
            visited[num]++;
            explore(nums, k, index + 1);    // 包含當前元素的分支，包含這個元素在當前子集中。
            visited[num]--;
            if (visited[num] == 0) {
                visited.erase(num);
            }
        }

        explore(nums, k, index + 1);        // 不包含當前元素的分支，不包含這個元素在當前子集中。
    }
};

// backtracking, dfs.
// bhanu_bhakta's solution.

/*

在回溯算法中，包含和不包含當前元素是構建所有可能子集的核心原理。
這種方法使得我們能夠探索每一個元素的所有可能組合，從而找到所有符合條件的子集。

回溯算法的工作原理：
回溯算法是一種系統地遍歷所有可能選擇的方法。對於每一個元素，有兩個選擇：

包含這個元素在當前子集中。
不包含這個元素在當前子集中。
這兩個選擇形成了一棵二叉樹狀的決策結構。這樣可以遍歷所有可能的子集。

具體例子：[2, 4, 6, 8] 和 k=2
考慮數組 [2, 4, 6, 8] 和 k=2，需要找出所有子集中任意兩個元素的差不等於 k 的子集。通過回溯，可以探索所有可能的子集組合。

回溯步驟：

起始狀態：
當前子集為空 []，從索引 0 開始。

第一層選擇：
    包含 2：當前子集為 [2]。
    不包含 2：當前子集為 []。

第二層選擇：
    如果包含了 2，接下來處理 [4, 6, 8]。
    包含 4：當前子集為 [2, 4]（但 4 - 2 = 2，不允許）。
    不包含 4：當前子集保持為 [2]，繼續處理 [6, 8]。
    如果不包含 2，接下來處理 [4, 6, 8]。
    包含 4：當前子集為 [4]。
    不包含 4：當前子集為 []。

第三層選擇：
    在包含 2 且不包含 4 的分支中：
    包含 6：當前子集為 [2, 6]（允許，因為 6 - 2 = 4，不等於 k）。
    不包含 6：當前子集為 [2]，繼續處理 [8]。
    在包含 2 且不包含 4 的分支中：
    包含 8：當前子集為 [2, 8]（允許，因為 8 - 2 = 6，不等於 k）。
    不包含 8：當前子集為 [2]。
    在包含 4 的分支中：
    包含 6：當前子集為 [4, 6]（不允許，因為 6 - 4 = 2）。
    不包含 6：當前子集為 [4]，繼續處理 [8]。
    在包含 4 的分支中：
    包含 8：當前子集為 [4, 8]（允許，因為 8 - 4 = 4，不等於 k）。
    不包含 8：當前子集為 [4]。
    在不包含 4 的分支中：
    包含 6：當前子集為 [6]。
    不包含 6：當前子集為 []，繼續處理 [8]。

第四層選擇：
    在包含 6 的分支中：
    包含 8：當前子集為 [6, 8]（允許，因為 8 - 6 = 2，不等於 k）。
    不包含 8：當前子集為 [6]。
    在不包含 6 的分支中：
    包含 8：當前子集為 [8]。
    不包含 8：當前子集為 []。

產生所有子集：
    通過這個遞歸過程，算法會生成所有可能的子集。

*/